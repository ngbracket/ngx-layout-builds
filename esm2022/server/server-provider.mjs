/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { DOCUMENT } from '@angular/common';
import { BEFORE_APP_SERIALIZED } from '@angular/platform-server';
import { BREAKPOINTS, CLASS_NAME, MediaMarshaller, SERVER_TOKEN, sortAscendingPriority, StylesheetMap, ÉµMatchMedia as MatchMedia, } from '@ngbracket/ngx-layout/core';
import { ServerMatchMedia } from './server-match-media';
import { CSP_NONCE, Inject, Optional } from '@angular/core';
/**
 * Activate all the registered breakpoints in sequence, and then
 * retrieve the associated stylings from the virtual stylesheet
 * @param serverSheet the virtual stylesheet that stores styles for each
 *        element
 * @param mediaController the MatchMedia service to activate/deactivate breakpoints
 * @param breakpoints the registered breakpoints to activate/deactivate
 * @param mediaMarshaller the MediaMarshaller service to disable fallback styles dynamically
 */
export function generateStaticFlexLayoutStyles(serverSheet, mediaController, breakpoints, mediaMarshaller) {
    // Store the custom classes in the following map, that way only
    // one class gets allocated per HTMLElement, and each class can
    // be referenced in the static media queries
    const classMap = new Map();
    // Get the initial stylings for all the directives,
    // and initialize the fallback block of stylings.
    const defaultStyles = new Map(serverSheet.stylesheet);
    // Reset the class counter, otherwise class numbers will
    // increase with each server render.
    nextId = 0;
    let styleText = generateCss(defaultStyles, 'all', classMap);
    mediaMarshaller.useFallbacks = false;
    [...breakpoints].sort(sortAscendingPriority).forEach((bp) => {
        serverSheet.clearStyles();
        mediaController.activateBreakpoint(bp);
        const stylesheet = new Map(serverSheet.stylesheet);
        if (stylesheet.size > 0) {
            styleText += generateCss(stylesheet, bp.mediaQuery, classMap);
        }
        mediaController.deactivateBreakpoint(bp);
    });
    return styleText;
}
/**
 * Create a style tag populated with the dynamic stylings from Flex
 * components and attach it to the head of the DOM
 */
export function FLEX_SSR_SERIALIZER_FACTORY(serverSheet, mediaController, _document, breakpoints, mediaMarshaller, _nonce) {
    return () => {
        // This is the style tag that gets inserted into the head of the DOM,
        // populated with the manual media queries
        const styleTag = _document.createElement('style');
        if (_nonce) {
            styleTag.setAttribute('nonce', _nonce);
        }
        const styleText = generateStaticFlexLayoutStyles(serverSheet, mediaController, breakpoints, mediaMarshaller);
        styleTag.classList.add(`${CLASS_NAME}ssr`);
        styleTag.textContent = styleText;
        _document.head.appendChild(styleTag);
    };
}
/**
 *  Provider to set static styles on the server
 */
export const SERVER_PROVIDERS = [
    {
        provide: BEFORE_APP_SERIALIZED,
        useFactory: FLEX_SSR_SERIALIZER_FACTORY,
        deps: [
            StylesheetMap,
            MatchMedia,
            DOCUMENT,
            BREAKPOINTS,
            MediaMarshaller,
            [new Optional(), new Inject(CSP_NONCE)],
        ],
        multi: true,
    },
    {
        provide: SERVER_TOKEN,
        useValue: true,
    },
    {
        provide: MatchMedia,
        useClass: ServerMatchMedia,
    },
];
let nextId = 0;
const IS_DEBUG_MODE = false;
/**
 * create @media queries based on a virtual stylesheet
 * * Adds a unique class to each element and stores it
 *   in a shared classMap for later reuse
 * @param stylesheet the virtual stylesheet that stores styles for each
 *        element
 * @param mediaQuery the given @media CSS selector for the current breakpoint
 * @param classMap the map of HTML elements to class names to avoid duplications
 */
function generateCss(stylesheet, mediaQuery, classMap) {
    let css = '';
    stylesheet.forEach((styles, el) => {
        let keyVals = '';
        let className = getClassName(el, classMap);
        styles.forEach((v, k) => {
            keyVals += v ? format(`${k}:${v};`) : '';
        });
        if (keyVals) {
            // Build list of CSS styles; each with a className
            css += format(`.${className} {`, keyVals, '}');
        }
    });
    // Group 1 or more styles (each with className) in a specific mediaQuery
    return format(`@media ${mediaQuery} {`, css, '}');
}
/**
 * For debugging purposes, prefix css segment with linefeed(s) for easy
 * debugging purposes.
 */
function format(...list) {
    let result = '';
    list.forEach((css, i) => {
        result += IS_DEBUG_MODE ? formatSegment(css, i !== 0) : css;
    });
    return result;
}
function formatSegment(css, asPrefix = true) {
    return asPrefix ? `\n${css}` : `${css}\n`;
}
/**
 * Get className associated with CSS styling
 * If not found, generate global className and set
 * association.
 */
function getClassName(element, classMap) {
    let className = classMap.get(element);
    if (!className) {
        className = `${CLASS_NAME}${nextId++}`;
        classMap.set(element, className);
    }
    element.classList.add(className);
    return className;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmVyLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicy9mbGV4LWxheW91dC9zZXJ2ZXIvc2VydmVyLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7R0FNRztBQUNILE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNqRSxPQUFPLEVBRUwsV0FBVyxFQUNYLFVBQVUsRUFDVixlQUFlLEVBQ2YsWUFBWSxFQUNaLHFCQUFxQixFQUNyQixhQUFhLEVBQ2IsV0FBVyxJQUFJLFVBQVUsR0FDMUIsTUFBTSw0QkFBNEIsQ0FBQztBQUVwQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUN4RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFNUQ7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLFVBQVUsOEJBQThCLENBQzVDLFdBQTBCLEVBQzFCLGVBQWlDLEVBQ2pDLFdBQXlCLEVBQ3pCLGVBQWdDO0lBRWhDLCtEQUErRDtJQUMvRCwrREFBK0Q7SUFDL0QsNENBQTRDO0lBQzVDLE1BQU0sUUFBUSxHQUFHLElBQUksR0FBRyxFQUF1QixDQUFDO0lBRWhELG1EQUFtRDtJQUNuRCxpREFBaUQ7SUFDakQsTUFBTSxhQUFhLEdBQUcsSUFBSSxHQUFHLENBQUMsV0FBVyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RELHdEQUF3RDtJQUN4RCxvQ0FBb0M7SUFDcEMsTUFBTSxHQUFHLENBQUMsQ0FBQztJQUNYLElBQUksU0FBUyxHQUFHLFdBQVcsQ0FBQyxhQUFhLEVBQUUsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDO0lBQzVELGVBQWUsQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDO0lBRXJD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U0FBUyxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUVqQyxPQUFPLFNBQVMsQ0FBQztBQUNuQixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBCRUZPUkVfQVBQX1NFUklBTElaRUQgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1zZXJ2ZXInO1xuaW1wb3J0IHtcbiAgQnJlYWtQb2ludCxcbiAgQlJFQUtQT0lOVFMsXG4gIENMQVNTX05BTUUsXG4gIE1lZGlhTWFyc2hhbGxlcixcbiAgU0VSVkVSX1RPS0VOLFxuICBzb3J0QXNjZW5kaW5nUHJpb3JpdHksXG4gIFN0eWxlc2hlZXRNYXAsXG4gIMm1TWF0Y2hNZWRpYSBhcyBNYXRjaE1lZGlhLFxufSBmcm9tICdAbmdicmFja2V0L25neC1sYXlvdXQvY29yZSc7XG5cbmltcG9ydCB7IFNlcnZlck1hdGNoTWVkaWEgfSBmcm9tICcuL3NlcnZlci1tYXRjaC1tZWRpYSc7XG5pbXBvcnQgeyBDU1BfTk9OQ0UsIEluamVjdCwgT3B0aW9uYWwgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuLyoqXG4gKiBBY3RpdmF0ZSBhbGwgdGhlIHJlZ2lzdGVyZWQgYnJlYWtwb2ludHMgaW4gc2VxdWVuY2UsIGFuZCB0aGVuXG4gKiByZXRyaWV2ZSB0aGUgYXNzb2NpYXRlZCBzdHlsaW5ncyBmcm9tIHRoZSB2aXJ0dWFsIHN0eWxlc2hlZXRcbiAqIEBwYXJhbSBzZXJ2ZXJTaGVldCB0aGUgdmlydHVhbCBzdHlsZXNoZWV0IHRoYXQgc3RvcmVzIHN0eWxlcyBmb3IgZWFjaFxuICogICAgICAgIGVsZW1lbnRcbiAqIEBwYXJhbSBtZWRpYUNvbnRyb2xsZXIgdGhlIE1hdGNoTWVkaWEgc2VydmljZSB0byBhY3RpdmF0ZS9kZWFjdGl2YXRlIGJyZWFrcG9pbnRzXG4gKiBAcGFyYW0gYnJlYWtwb2ludHMgdGhlIHJlZ2lzdGVyZWQgYnJlYWtwb2ludHMgdG8gYWN0aXZhdGUvZGVhY3RpdmF0ZVxuICogQHBhcmFtIG1lZGlhTWFyc2hhbGxlciB0aGUgTWVkaWFNYXJzaGFsbGVyIHNlcnZpY2UgdG8gZGlzYWJsZSBmYWxsYmFjayBzdHlsZXMgZHluYW1pY2FsbHlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlU3RhdGljRmxleExheW91dFN0eWxlcyhcbiAgc2VydmVyU2hlZXQ6IFN0eWxlc2hlZXRNYXAsXG4gIG1lZGlhQ29udHJvbGxlcjogU2VydmVyTWF0Y2hNZWRpYSxcbiAgYnJlYWtwb2ludHM6IEJyZWFrUG9pbnRbXSxcbiAgbWVkaWFNYXJzaGFsbGVyOiBNZWRpYU1hcnNoYWxsZXJcbikge1xuICAvLyBTdG9yZSB0aGUgY3VzdG9tIGNsYXNzZXMgaW4gdGhlIGZvbGxvd2luZyBtYXAsIHRoYXQgd2F5IG9ubHlcbiAgLy8gb25lIGNsYXNzIGdldHMgYWxsb2NhdGVkIHBlciBIVE1MRWxlbWVudCwgYW5kIGVhY2ggY2xhc3MgY2FuXG4gIC8vIGJlIHJlZmVyZW5jZWQgaW4gdGhlIHN0YXRpYyBtZWRpYSBxdWVyaWVzXG4gIGNvbnN0IGNsYXNzTWFwID0gbmV3IE1hcDxIVE1MRWxlbWVudCwgc3RyaW5nPigpO1xuXG4gIC8vIEdldCB0aGUgaW5pdGlhbCBzdHlsaW5ncyBmb3IgYWxsIHRoZSBkaXJlY3RpdmVzLFxuICAvLyBhbmQgaW5pdGlhbGl6ZSB0aGUgZmFsbGJhY2sgYmxvY2sgb2Ygc3R5bGluZ3MuXG4gIGNvbnN0IGRlZmF1bHRTdHlsZXMgPSBuZXcgTWFwKHNlcnZlclNoZWV0LnN0eWxlc2hlZXQpO1xuICAvLyBSZXNldCB0aGUgY2xhc3MgY291bnRlciwgb3RoZXJ3aXNlIGNsYXNzIG51bWJlcnMgd2lsbFxuICAvLyBpbmNyZWFzZSB3aXRoIGVhY2ggc2VydmVyIHJlbmRlci5cbiAgbmV4dElkID0gMDtcbiAgbGV0IHN0eWxlVGV4dCA9IGdlbmVyYXRlQ3NzKGRlZmF1bHRTdHlsZXMsICdhbGwnLCBjbGFzc01hcCk7XG4gIG1lZGlhTWFyc2hhbGxlci51c2VGYWxsYmFja3MgPSBmYWxzZTtcblxuICBbLi4uYnJlYWtwb2ludHNdLnNvcnQoc29ydEFzY2VuZGluZ1ByaW9yaXR5KS5mb3JFYWNoKChicCkgPT4ge1xuICAgIHNlcnZlclNoZWV0LmNsZWFyU3R5bGVzKCk7XG4gICAgbWVkaWFDb250cm9sbGVyLmFjdGl2YXRlQnJlYWtwb2ludChicCk7XG4gICAgY29uc3Qgc3R5bGVzaGVldCA9IG5ldyBNYXAoc2VydmVyU2hlZXQuc3R5bGVzaGVldCk7XG4gICAgaWYgKHN0eWxlc2hlZXQuc2l6ZSA+IDApIHtcbiAgICAgIHN0eWxlVGV4dCArPSBnZW5lcmF0ZUNzcyhzdHlsZXNoZWV0LCBicC5tZWRpYVF1ZXJ5LCBjbGFzc01hcCk7XG4gICAgfVxuICAgIG1lZGlhQ29udHJvbGxlci5kZWFjdGl2YXRlQnJlYWtwb2ludChicCk7XG4gIH0pO1xuXG4gIHJldHVybiBzdHlsZVRleHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgc3R5bGUgdGFnIHBvcHVsYXRlZCB3aXRoIHRoZSBkeW5hbWljIHN0eWxpbmdzIGZyb20gRmxleFxuICogY29tcG9uZW50cyBhbmQgYXR0YWNoIGl0IHRvIHRoZSBoZWFkIG9mIHRoZSBET01cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZMRVhfU1NSX1NFUklBTElaRVJfRkFDVE9SWShcbiAgc2VydmVyU2hlZXQ6IFN0eWxlc2hlZXRNYXAsXG4gIG1lZGlhQ29udHJvbGxlcjogU2VydmVyTWF0Y2hNZWRpYSxcbiAgX2RvY3VtZW50OiBEb2N1bWVudCxcbiAgYnJlYWtwb2ludHM6IEJyZWFrUG9pbnRbXSxcbiAgbWVkaWFNYXJzaGFsbGVyOiBNZWRpYU1hcnNoYWxsZXIsXG4gIF9ub25jZT86IHN0cmluZ1xuKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc3R5bGUgdGFnIHRoYXQgZ2V0cyBpbnNlcnRlZCBpbnRvIHRoZSBoZWFkIG9mIHRoZSBET00sXG4gICAgLy8gcG9wdWxhdGVkIHdpdGggdGhlIG1hbnVhbCBtZWRpYSBxdWVyaWVzXG4gICAgY29uc3Qgc3R5bGVUYWcgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICBpZiAoX25vbmNlKSB7XG4gICAgICBzdHlsZVRhZy5zZXRBdHRyaWJ1dGUoJ25vbmNlJywgX25vbmNlKTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVUZXh0ID0gZ2VuZXJhdGVTdGF0aWNGbGV4TGF5b3V0U3R5bGVzKFxuICAgICAgc2VydmVyU2hlZXQsXG4gICAgICBtZWRpYUNvbnRyb2xsZXIsXG4gICAgICBicmVha3BvaW50cyxcbiAgICAgIG1lZGlhTWFyc2hhbGxlclxuICAgICk7XG4gICAgc3R5bGVUYWcuY2xhc3NMaXN0LmFkZChgJHtDTEFTU19OQU1FfXNzcmApO1xuICAgIHN0eWxlVGFnLnRleHRDb250ZW50ID0gc3R5bGVUZXh0O1xuICAgIF9kb2N1bWVudC5oZWFkIS5hcHBlbmRDaGlsZChzdHlsZVRhZyk7XG4gIH07XG59XG5cbi8qKlxuICogIFByb3ZpZGVyIHRvIHNldCBzdGF0aWMgc3R5bGVzIG9uIHRoZSBzZXJ2ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IFNFUlZFUl9QUk9WSURFUlMgPSBbXG4gIHtcbiAgICBwcm92aWRlOiBCRUZPUkVfQVBQX1NFUklBTElaRUQsXG4gICAgdXNlRmFjdG9yeTogRkxFWF9TU1JfU0VSSUFMSVpFUl9GQUNUT1JZLFxuICAgIGRlcHM6IFtcbiAgICAgIFN0eWxlc2hlZXRNYXAsXG4gICAgICBNYXRjaE1lZGlhLFxuICAgICAgRE9DVU1FTlQsXG4gICAgICBCUkVBS1BPSU5UUyxcbiAgICAgIE1lZGlhTWFyc2hhbGxlcixcbiAgICAgIFtuZXcgT3B0aW9uYWwoKSwgbmV3IEluamVjdChDU1BfTk9OQ0UpXSxcbiAgICBdLFxuICAgIG11bHRpOiB0cnVlLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZTogU0VSVkVSX1RPS0VOLFxuICAgIHVzZVZhbHVlOiB0cnVlLFxuICB9LFxuICB7XG4gICAgcHJvdmlkZTogTWF0Y2hNZWRpYSxcbiAgICB1c2VDbGFzczogU2VydmVyTWF0Y2hNZWRpYSxcbiAgfSxcbl07XG5cbmxldCBuZXh0SWQgPSAwO1xuY29uc3QgSVNfREVCVUdfTU9ERSA9IGZhbHNlO1xuXG5leHBvcnQgdHlwZSBTdHlsZVNoZWV0ID0gTWFwPEhUTUxFbGVtZW50LCBNYXA8c3RyaW5nLCBzdHJpbmcgfCBudW1iZXI+PjtcbmV4cG9ydCB0eXBlIENsYXNzTWFwID0gTWFwPEhUTUxFbGVtZW50LCBzdHJpbmc+O1xuXG4vKipcbiAqIGNyZWF0ZSBAbWVkaWEgcXVlcmllcyBiYXNlZCBvbiBhIHZpcnR1YWwgc3R5bGVzaGVldFxuICogKiBBZGRzIGEgdW5pcXVlIGNsYXNzIHRvIGVhY2ggZWxlbWVudCBhbmQgc3RvcmVzIGl0XG4gKiAgIGluIGEgc2hhcmVkIGNsYXNzTWFwIGZvciBsYXRlciByZXVzZVxuICogQHBhcmFtIHN0eWxlc2hlZXQgdGhlIHZpcnR1YWwgc3R5bGVzaGVldCB0aGF0IHN0b3JlcyBzdHlsZXMgZm9yIGVhY2hcbiAqICAgICAgICBlbGVtZW50XG4gKiBAcGFyYW0gbWVkaWFRdWVyeSB0aGUgZ2l2ZW4gQG1lZGlhIENTUyBzZWxlY3RvciBmb3IgdGhlIGN1cnJlbnQgYnJlYWtwb2ludFxuICogQHBhcmFtIGNsYXNzTWFwIHRoZSBtYXAgb2YgSFRNTCBlbGVtZW50cyB0byBjbGFzcyBuYW1lcyB0byBhdm9pZCBkdXBsaWNhdGlvbnNcbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVDc3MoXG4gIHN0eWxlc2hlZXQ6IFN0eWxlU2hlZXQsXG4gIG1lZGlhUXVlcnk6IHN0cmluZyxcbiAgY2xhc3NNYXA6IENsYXNzTWFwXG4pIHtcbiAgbGV0IGNzcyA9ICcnO1xuICBzdHlsZXNoZWV0LmZvckVhY2goKHN0eWxlcywgZWwpID0+IHtcbiAgICBsZXQga2V5VmFscyA9ICcnO1xuICAgIGxldCBjbGFzc05hbWUgPSBnZXRDbGFzc05hbWUoZWwsIGNsYXNzTWFwKTtcblxuICAgIHN0eWxlcy5mb3JFYWNoKCh2LCBrKSA9PiB7XG4gICAgICBrZXlWYWxzICs9IHYgPyBmb3JtYXQoYCR7a306JHt2fTtgKSA6ICcnO1xuICAgIH0pO1xuXG4gICAgaWYgKGtleVZhbHMpIHtcbiAgICAgIC8vIEJ1aWxkIGxpc3Qgb2YgQ1NTIHN0eWxlczsgZWFjaCB3aXRoIGEgY2xhc3NOYW1lXG4gICAgICBjc3MgKz0gZm9ybWF0KGAuJHtjbGFzc05hbWV9IHtgLCBrZXlWYWxzLCAnfScpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gR3JvdXAgMSBvciBtb3JlIHN0eWxlcyAoZWFjaCB3aXRoIGNsYXNzTmFtZSkgaW4gYSBzcGVjaWZpYyBtZWRpYVF1ZXJ5XG4gIHJldHVybiBmb3JtYXQoYEBtZWRpYSAke21lZGlhUXVlcnl9IHtgLCBjc3MsICd9Jyk7XG59XG5cbi8qKlxuICogRm9yIGRlYnVnZ2luZyBwdXJwb3NlcywgcHJlZml4IGNzcyBzZWdtZW50IHdpdGggbGluZWZlZWQocykgZm9yIGVhc3lcbiAqIGRlYnVnZ2luZyBwdXJwb3Nlcy5cbiAqL1xuZnVuY3Rpb24gZm9ybWF0KC4uLmxpc3Q6IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgbGV0IHJlc3VsdCA9ICcnO1xuICBsaXN0LmZvckVhY2goKGNzcywgaSkgPT4ge1xuICAgIHJlc3VsdCArPSBJU19ERUJVR19NT0RFID8gZm9ybWF0U2VnbWVudChjc3MsIGkgIT09IDApIDogY3NzO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0U2VnbWVudChjc3M6IHN0cmluZywgYXNQcmVmaXg6IGJvb2xlYW4gPSB0cnVlKTogc3RyaW5nIHtcbiAgcmV0dXJuIGFzUHJlZml4ID8gYFxcbiR7Y3NzfWAgOiBgJHtjc3N9XFxuYDtcbn1cblxuLyoqXG4gKiBHZXQgY2xhc3NOYW1lIGFzc29jaWF0ZWQgd2l0aCBDU1Mgc3R5bGluZ1xuICogSWYgbm90IGZvdW5kLCBnZW5lcmF0ZSBnbG9iYWwgY2xhc3NOYW1lIGFuZCBzZXRcbiAqIGFzc29jaWF0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDbGFzc05hbWUoXG4gIGVsZW1lbnQ6IEhUTUxFbGVtZW50LFxuICBjbGFzc01hcDogTWFwPEhUTUxFbGVtZW50LCBzdHJpbmc+XG4pIHtcbiAgbGV0IGNsYXNzTmFtZSA9IGNsYXNzTWFwLmdldChlbGVtZW50KTtcbiAgaWYgKCFjbGFzc05hbWUpIHtcbiAgICBjbGFzc05hbWUgPSBgJHtDTEFTU19OQU1FfSR7bmV4dElkKyt9YDtcbiAgICBjbGFzc01hcC5zZXQoZWxlbWVudCwgY2xhc3NOYW1lKTtcbiAgfVxuICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcblxuICByZXR1cm4gY2xhc3NOYW1lO1xufVxuIl19