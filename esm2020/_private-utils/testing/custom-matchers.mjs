const _global = (typeof window === 'undefined' ? global : window);
import { _dom as _ } from './dom-tools';
import { applyCssPrefixes, extendObject, } from '@ngbracket/ngx-layout/_private-utils';
export const expect = _global.expect;
/**
 * NOTE: These custom JASMINE Matchers are used only
 *       in the Karma/Jasmine testing for the Layout Directives
 *       in `src/lib/flex/api`
 */
export const customMatchers = {
    toEqual: function (util) {
        return {
            compare: function (actual, expected) {
                return { pass: util.equals(actual, expected) };
            },
        };
    },
    toHaveText: function () {
        return {
            compare: function (actual, expectedText) {
                const actualText = elementText(actual);
                return {
                    pass: actualText == expectedText,
                    get message() {
                        return 'Expected ' + actualText + ' to be equal to ' + expectedText;
                    },
                };
            },
        };
    },
    toHaveCssClass: function () {
        return { compare: buildError(false), negativeCompare: buildError(true) };
        function buildError(isNot) {
            return function (actual, className) {
                return {
                    pass: _.hasClass(actual, className) == !isNot,
                    get message() {
                        return `
              Expected ${actual.outerHTML} ${isNot ? 'not ' : ''}
              to contain the CSS class '${className}'
            `;
                    },
                };
            };
        }
    },
    toHaveMap: function () {
        return {
            compare: function (actual, map) {
                let allPassed;
                allPassed = Object.keys(map).length !== 0;
                Object.keys(map).forEach((key) => {
                    allPassed = allPassed && actual[key] === map[key];
                });
                return {
                    pass: allPassed,
                    get message() {
                        return `
              Expected ${JSON.stringify(actual)} ${!allPassed ? ' ' : 'not '} to contain the
              '${JSON.stringify(map)}'
            `;
                    },
                };
            },
        };
    },
    toHaveAttributes: function () {
        return {
            compare: function (actual, map) {
                let allPassed;
                let attributeNames = Object.keys(map);
                allPassed = attributeNames.length !== 0;
                attributeNames.forEach((name) => {
                    allPassed =
                        allPassed &&
                            _.hasAttribute(actual, name) &&
                            _.getAttribute(actual, name) === map[name];
                });
                return {
                    pass: allPassed,
                    get message() {
                        return `
              Expected ${actual.outerHTML} ${allPassed ? 'not ' : ''} attributes to contain
              '${JSON.stringify(map)}'
            `;
                    },
                };
            },
        };
    },
    /**
     * Check element's inline styles only
     */
    toHaveStyle: function () {
        return {
            compare: buildCompareStyleFunction(true),
        };
    },
    /**
     * Check element's css stylesheet only (if not present inline)
     */
    toHaveCSS: function () {
        return {
            compare: buildCompareStyleFunction(false),
        };
    },
};
/**
 * Curried value to function to check styles that are inline or in a stylesheet for the
 * specified DOM element.
 */
function buildCompareStyleFunction(inlineOnly = true) {
    return function (actual, styles, styler) {
        const found = {};
        const styleMap = {};
        if (typeof styles === 'string') {
            styleMap[styles] = '';
        }
        else {
            Object.assign(styleMap, styles);
        }
        let allPassed = Object.keys(styleMap).length !== 0;
        Object.keys(styleMap).forEach((prop) => {
            let { elHasStyle, current } = hasPrefixedStyles(actual, prop, styleMap[prop], inlineOnly, styler);
            allPassed = allPassed && elHasStyle;
            if (!elHasStyle) {
                extendObject(found, current);
            }
        });
        return {
            pass: allPassed,
            get message() {
                const expectedValueStr = typeof styles === 'string'
                    ? styleMap
                    : JSON.stringify(styleMap, null, 2);
                const foundValueStr = inlineOnly
                    ? actual.outerHTML
                    : JSON.stringify(found);
                return `
          Expected ${foundValueStr}${!allPassed ? '' : ' not'} to contain the
          CSS ${typeof styles === 'string' ? 'property' : 'styles'} '${expectedValueStr}'
        `;
            },
        };
    };
}
/**
 * Validate presence of requested style or use fallback
 * to possible `prefixed` styles. Useful when some browsers
 * (Safari, IE, etc) will use prefixed style instead of defaults.
 */
function hasPrefixedStyles(actual, key, value, inlineOnly, styler) {
    const current = {};
    if (value === '*') {
        return {
            elHasStyle: styler.lookupStyle(actual, key, inlineOnly) !== '',
            current,
        };
    }
    value = value.trim();
    let elHasStyle = styler.lookupStyle(actual, key, inlineOnly) === value;
    if (!elHasStyle) {
        let prefixedStyles = applyCssPrefixes({ [key]: value });
        Object.keys(prefixedStyles).forEach((prop) => {
            // Search for optional prefixed values
            elHasStyle =
                elHasStyle ||
                    styler.lookupStyle(actual, prop, inlineOnly) === prefixedStyles[prop];
        });
    }
    // Return BOTH confirmation and current computed key values (if confirmation == false)
    return { elHasStyle, current };
}
function elementText(n) {
    const hasNodes = (m) => {
        const children = _.childNodes(m);
        return children && children['length'];
    };
    if (n instanceof Array) {
        return n.map(elementText).join('');
    }
    if (_.isCommentNode(n)) {
        return '';
    }
    if (_.isElementNode(n) && _.tagName(n) == 'CONTENT') {
        return elementText(Array.prototype.slice.apply(_.getDistributedNodes(n)));
    }
    if (_.hasShadowRoot(n)) {
        return elementText(_.childNodesAsList(_.getShadowRoot(n)));
    }
    if (hasNodes(n)) {
        return elementText(_.childNodesAsList(n));
    }
    return _.getText(n);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLW1hdGNoZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicy9mbGV4LWxheW91dC9fcHJpdmF0ZS11dGlscy90ZXN0aW5nL2N1c3RvbS1tYXRjaGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxNQUFNLE9BQU8sR0FBUSxDQUFDLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV2RSxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUd4QyxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFlBQVksR0FDYixNQUFNLHNDQUFzQyxDQUFDO0FBRTlDLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBcUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQTBEdkU7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBbUM7SUFDNUQsT0FBTyxFQUFFLFVBQVUsSUFBSTtRQUNyQixPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQVUsTUFBVyxFQUFFLFFBQWE7Z0JBQzNDLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUNqRCxDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLEVBQUU7UUFDVixPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQVUsTUFBVyxFQUFFLFlBQW9CO2dCQUNsRCxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3ZDLE9BQU87b0JBQ0wsSUFBSSxFQUFFLFVBQVUsSUFBSSxZQUFZO29CQUNoQyxJQUFJLE9BQU87d0JBQ1QsT0FBTyxXQUFXLEdBQUcsVUFBVSxHQUFHLGtCQUFrQixHQUFHLFlBQVksQ0FBQztvQkFDdEUsQ0FBQztpQkFDRixDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsY0FBYyxFQUFFO1FBQ2QsT0FBTyxFQUFFLE9BQU8sRUFBRSxVQUFVLENBQUMsS0FBSyxDQUFDLEVBQUUsZUFBZSxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBRXpFLFNBQVMsVUFBVSxDQUFDLEtBQWM7WUFDaEMsT0FBTyxVQUFVLE1BQVcsRUFBRSxTQUFpQjtnQkFDN0MsT0FBTztvQkFDTCxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxLQUFLO29CQUM3QyxJQUFJLE9BQU87d0JBQ1QsT0FBTzt5QkFDTSxNQUFNLENBQUMsU0FBUyxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFOzBDQUN0QixTQUFTO2FBQ3RDLENBQUM7b0JBQ0osQ0FBQztpQkFDRixDQUFDO1lBQ0osQ0FBQyxDQUFDO1FBQ0osQ0FBQztJQUNILENBQUM7SUFFRCxTQUFTLEVBQUU7UUFDVCxPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQ1AsTUFBK0IsRUFDL0IsR0FBNEI7Z0JBRTVCLElBQUksU0FBa0IsQ0FBQztnQkFDdkIsU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztnQkFDMUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEVBQUUsRUFBRTtvQkFDL0IsU0FBUyxHQUFHLFNBQVMsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLEtBQUssR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUNwRCxDQUFDLENBQUMsQ0FBQztnQkFFSCxPQUFPO29CQUNMLElBQUksRUFBRSxTQUFTO29CQUNmLElBQUksT0FBTzt3QkFDVCxPQUFPO3lCQUNNLElBQUksQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLElBQ2pDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLE1BQ3JCO2lCQUNLLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDO2FBQ3ZCLENBQUM7b0JBQ0osQ0FBQztpQkFDRixDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDO0lBRUQsZ0JBQWdCLEVBQUU7UUFDaEIsT0FBTztZQUNMLE9BQU8sRUFBRSxVQUFVLE1BQVcsRUFBRSxHQUE0QjtnQkFDMUQsSUFBSSxTQUFrQixDQUFDO2dCQUN2QixJQUFJLGNBQWMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN0QyxTQUFTLEdBQUcsY0FBYyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7Z0JBQ3hDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLEVBQUUsRUFBRTtvQkFDOUIsU0FBUzt3QkFDUCxTQUFTOzRCQUNULENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQzs0QkFDNUIsQ0FBQyxDQUFDLFlBQVksQ0FBQyxNQUFNLEVBQUUsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUMvQyxDQUFDLENBQUMsQ0FBQztnQkFDSCxPQUFPO29CQUNMLElBQUksRUFBRSxTQUFTO29CQUNmLElBQUksT0FBTzt3QkFDVCxPQUFPO3lCQUNNLE1BQU0sQ0FBQyxTQUFTLElBQzNCLFNBQVMsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUN2QjtpQkFDSyxJQUFJLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQzthQUN2QixDQUFDO29CQUNKLENBQUM7aUJBQ0YsQ0FBQztZQUNKLENBQUM7U0FDRixDQUFDO0lBQ0osQ0FBQztJQUVEOztPQUVHO0lBQ0gsV0FBVyxFQUFFO1FBQ1gsT0FBTztZQUNMLE9BQU8sRUFBRSx5QkFBeUIsQ0FBQyxJQUFJLENBQUM7U0FDekMsQ0FBQztJQUNKLENBQUM7SUFFRDs7T0FFRztJQUNILFNBQVMsRUFBRTtRQUNULE9BQU87WUFDTCxPQUFPLEVBQUUseUJBQXlCLENBQUMsS0FBSyxDQUFDO1NBQzFDLENBQUM7SUFDSixDQUFDO0NBQ0YsQ0FBQztBQUVGOzs7R0FHRztBQUNILFNBQVMseUJBQXlCLENBQUMsVUFBVSxHQUFHLElBQUk7SUFDbEQsT0FBTyxVQUNMLE1BQVcsRUFDWCxNQUF3QyxFQUN4QyxNQUFrQjtRQUVsQixNQUFNLEtBQUssR0FBRyxFQUFFLENBQUM7UUFDakIsTUFBTSxRQUFRLEdBQTRCLEVBQUUsQ0FBQztRQUU3QyxJQUFJLE9BQU8sTUFBTSxLQUFLLFFBQVEsRUFBRTtZQUM5QixRQUFRLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3ZCO2FBQU07WUFDTCxNQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsQ0FBQztTQUNqQztRQUVELElBQUksU0FBUyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsQ0FBQztRQUNuRCxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ3JDLElBQUksRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLEdBQUcsaUJBQWlCLENBQzdDLE1BQU0sRUFDTixJQUFJLEVBQ0osUUFBUSxDQUFDLElBQUksQ0FBQyxFQUNkLFVBQVUsRUFDVixNQUFNLENBQ1AsQ0FBQztZQUNGLFNBQVMsR0FBRyxTQUFTLElBQUksVUFBVSxDQUFDO1lBQ3BDLElBQUksQ0FBQyxVQUFVLEVBQUU7Z0JBQ2YsWUFBWSxDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQzthQUM5QjtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTztZQUNMLElBQUksRUFBRSxTQUFTO1lBQ2YsSUFBSSxPQUFPO2dCQUNULE1BQU0sZ0JBQWdCLEdBQ3BCLE9BQU8sTUFBTSxLQUFLLFFBQVE7b0JBQ3hCLENBQUMsQ0FBQyxRQUFRO29CQUNWLENBQUMsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7Z0JBQ3hDLE1BQU0sYUFBYSxHQUFHLFVBQVU7b0JBQzlCLENBQUMsQ0FBQyxNQUFNLENBQUMsU0FBUztvQkFDbEIsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7Z0JBQzFCLE9BQU87cUJBQ00sYUFBYSxHQUFHLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU07Z0JBRWpELE9BQU8sTUFBTSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxRQUM1QyxLQUFLLGdCQUFnQjtTQUN0QixDQUFDO1lBQ0osQ0FBQztTQUNGLENBQUM7SUFDSixDQUFDLENBQUM7QUFDSixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQVMsaUJBQWlCLENBQ3hCLE1BQW1CLEVBQ25CLEdBQVcsRUFDWCxLQUFhLEVBQ2IsVUFBbUIsRUFDbkIsTUFBa0I7SUFFbEIsTUFBTSxPQUFPLEdBQUcsRUFBRSxDQUFDO0lBRW5CLElBQUksS0FBSyxLQUFLLEdBQUcsRUFBRTtRQUNqQixPQUFPO1lBQ0wsVUFBVSxFQUFFLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxVQUFVLENBQUMsS0FBSyxFQUFFO1lBQzlELE9BQU87U0FDUixDQUFDO0tBQ0g7SUFFRCxLQUFLLEdBQUcsS0FBSyxDQUFDLElBQUksRUFBRSxDQUFDO0lBQ3JCLElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxVQUFVLENBQUMsS0FBSyxLQUFLLENBQUM7SUFDdkUsSUFBSSxDQUFDLFVBQVUsRUFBRTtRQUNmLElBQUksY0FBYyxHQUFHLGdCQUFnQixDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7WUFDM0Msc0NBQXNDO1lBQ3RDLFVBQVU7Z0JBQ1IsVUFBVTtvQkFDVixNQUFNLENBQUMsV0FBVyxDQUFDLE1BQU0sRUFBRSxJQUFJLEVBQUUsVUFBVSxDQUFDLEtBQUssY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzFFLENBQUMsQ0FBQyxDQUFDO0tBQ0o7SUFDRCxzRkFBc0Y7SUFDdEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsQ0FBQztBQUNqQyxDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsQ0FBTTtJQUN6QixNQUFNLFFBQVEsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFO1FBQzFCLE1BQU0sUUFBUSxHQUFHLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDakMsT0FBTyxRQUFRLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQ3hDLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQyxZQUFZLEtBQUssRUFBRTtRQUN0QixPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0tBQ3BDO0lBRUQsSUFBSSxDQUFDLENBQUMsYUFBYSxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sRUFBRSxDQUFDO0tBQ1g7SUFFRCxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsSUFBSSxTQUFTLEVBQUU7UUFDbkQsT0FBTyxXQUFXLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7S0FDM0U7SUFFRCxJQUFJLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxXQUFXLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVEO0lBRUQsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDZixPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMzQztJQUVELE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5kZWNsYXJlIHZhciBnbG9iYWw6IGFueTtcbmNvbnN0IF9nbG9iYWwgPSA8YW55Pih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyk7XG5cbmltcG9ydCB7IF9kb20gYXMgXyB9IGZyb20gJy4vZG9tLXRvb2xzJztcblxuaW1wb3J0IHsgU3R5bGVVdGlscyB9IGZyb20gJ0BuZ2JyYWNrZXQvbmd4LWxheW91dC9jb3JlJztcbmltcG9ydCB7XG4gIGFwcGx5Q3NzUHJlZml4ZXMsXG4gIGV4dGVuZE9iamVjdCxcbn0gZnJvbSAnQG5nYnJhY2tldC9uZ3gtbGF5b3V0L19wcml2YXRlLXV0aWxzJztcblxuZXhwb3J0IGNvbnN0IGV4cGVjdDogKGFjdHVhbDogYW55KSA9PiBOZ01hdGNoZXJzID0gPGFueT5fZ2xvYmFsLmV4cGVjdDtcblxuLyoqXG4gKiBKYXNtaW5lIG1hdGNoZXJzIHRoYXQgY2hlY2sgQW5ndWxhciBzcGVjaWZpYyBjb25kaXRpb25zLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5nTWF0Y2hlcnMgZXh0ZW5kcyBqYXNtaW5lLk1hdGNoZXJzPGFueT4ge1xuICAvKipcbiAgICogRXhwZWN0IHRoZSBlbGVtZW50IHRvIGhhdmUgZXhhY3RseSB0aGUgZ2l2ZW4gdGV4dC5cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgdGVzdGluZy90cy9tYXRjaGVycy50cyByZWdpb249J3RvSGF2ZVRleHQnfVxuICAgKi9cbiAgdG9IYXZlVGV4dChleHBlY3RlZDogc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogQ29tcGFyZSBrZXk6dmFsdWUgcGFpcnMgYXMgbWF0Y2hpbmcgRVhBQ1RMWVxuICAgKi9cbiAgdG9IYXZlTWFwKGV4cGVjdGVkOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGUgZWxlbWVudCB0byBoYXZlIHRoZSBnaXZlbiBDU1MgY2xhc3MuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICoge0BleGFtcGxlIHRlc3RpbmcvdHMvbWF0Y2hlcnMudHMgcmVnaW9uPSd0b0hhdmVDc3NDbGFzcyd9XG4gICAqL1xuICB0b0hhdmVDc3NDbGFzcyhleHBlY3RlZDogc3RyaW5nKTogYm9vbGVhbjtcblxuICAvKipcbiAgICogRXhwZWN0IHRoZSBlbGVtZW50IHRvIGhhdmUgdGhlIGdpdmVuIHBhaXJzIG9mIGF0dHJpYnV0ZSBuYW1lIGFuZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICovXG4gIHRvSGF2ZUF0dHJpYnV0ZXMoZXhwZWN0ZWQ6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogRXhwZWN0IHRoZSBlbGVtZW50IHRvIGhhdmUgdGhlIGdpdmVuIENTUyBzdHlsZXMgaW5qZWN0ZWQgSU5MSU5FXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICoge0BleGFtcGxlIHRlc3RpbmcvdHMvbWF0Y2hlcnMudHMgcmVnaW9uPSd0b0hhdmVTdHlsZSd9XG4gICAqL1xuICB0b0hhdmVTdHlsZShleHBlY3RlZDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0gfCBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhlIGVsZW1lbnQgdG8gaGF2ZSB0aGUgZ2l2ZW4gQ1NTIGlubGluZSBPUiBjb21wdXRlZCBzdHlsZXMuXG4gICAqXG4gICAqICMjIEV4YW1wbGVcbiAgICpcbiAgICoge0BleGFtcGxlIHRlc3RpbmcvdHMvbWF0Y2hlcnMudHMgcmVnaW9uPSd0b0hhdmVTdHlsZSd9XG4gICAqL1xuICB0b0hhdmVTdHlsZShleHBlY3RlZDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0gfCBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbnZlcnQgdGhlIG1hdGNoZXJzLlxuICAgKi9cbiAgbm90OiBOZ01hdGNoZXJzO1xufVxuXG4vKipcbiAqIE5PVEU6IFRoZXNlIGN1c3RvbSBKQVNNSU5FIE1hdGNoZXJzIGFyZSB1c2VkIG9ubHlcbiAqICAgICAgIGluIHRoZSBLYXJtYS9KYXNtaW5lIHRlc3RpbmcgZm9yIHRoZSBMYXlvdXQgRGlyZWN0aXZlc1xuICogICAgICAgaW4gYHNyYy9saWIvZmxleC9hcGlgXG4gKi9cbmV4cG9ydCBjb25zdCBjdXN0b21NYXRjaGVyczogamFzbWluZS5DdXN0b21NYXRjaGVyRmFjdG9yaWVzID0ge1xuICB0b0VxdWFsOiBmdW5jdGlvbiAodXRpbCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoYWN0dWFsOiBhbnksIGV4cGVjdGVkOiBhbnkpIHtcbiAgICAgICAgcmV0dXJuIHsgcGFzczogdXRpbC5lcXVhbHMoYWN0dWFsLCBleHBlY3RlZCkgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcblxuICB0b0hhdmVUZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChhY3R1YWw6IGFueSwgZXhwZWN0ZWRUZXh0OiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgYWN0dWFsVGV4dCA9IGVsZW1lbnRUZXh0KGFjdHVhbCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWN0dWFsVGV4dCA9PSBleHBlY3RlZFRleHQsXG4gICAgICAgICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0V4cGVjdGVkICcgKyBhY3R1YWxUZXh0ICsgJyB0byBiZSBlcXVhbCB0byAnICsgZXhwZWN0ZWRUZXh0O1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG5cbiAgdG9IYXZlQ3NzQ2xhc3M6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4geyBjb21wYXJlOiBidWlsZEVycm9yKGZhbHNlKSwgbmVnYXRpdmVDb21wYXJlOiBidWlsZEVycm9yKHRydWUpIH07XG5cbiAgICBmdW5jdGlvbiBidWlsZEVycm9yKGlzTm90OiBib29sZWFuKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKGFjdHVhbDogYW55LCBjbGFzc05hbWU6IHN0cmluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IF8uaGFzQ2xhc3MoYWN0dWFsLCBjbGFzc05hbWUpID09ICFpc05vdCxcbiAgICAgICAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIEV4cGVjdGVkICR7YWN0dWFsLm91dGVySFRNTH0gJHtpc05vdCA/ICdub3QgJyA6ICcnfVxuICAgICAgICAgICAgICB0byBjb250YWluIHRoZSBDU1MgY2xhc3MgJyR7Y2xhc3NOYW1lfSdcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHRvSGF2ZU1hcDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBmdW5jdGlvbiAoXG4gICAgICAgIGFjdHVhbDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0sXG4gICAgICAgIG1hcDogeyBbazogc3RyaW5nXTogc3RyaW5nIH1cbiAgICAgICkge1xuICAgICAgICBsZXQgYWxsUGFzc2VkOiBib29sZWFuO1xuICAgICAgICBhbGxQYXNzZWQgPSBPYmplY3Qua2V5cyhtYXApLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgT2JqZWN0LmtleXMobWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICBhbGxQYXNzZWQgPSBhbGxQYXNzZWQgJiYgYWN0dWFsW2tleV0gPT09IG1hcFtrZXldO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFsbFBhc3NlZCxcbiAgICAgICAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIEV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoYWN0dWFsKX0gJHtcbiAgICAgICAgICAgICAgIWFsbFBhc3NlZCA/ICcgJyA6ICdub3QgJ1xuICAgICAgICAgICAgfSB0byBjb250YWluIHRoZVxuICAgICAgICAgICAgICAnJHtKU09OLnN0cmluZ2lmeShtYXApfSdcbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcblxuICB0b0hhdmVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChhY3R1YWw6IGFueSwgbWFwOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSkge1xuICAgICAgICBsZXQgYWxsUGFzc2VkOiBib29sZWFuO1xuICAgICAgICBsZXQgYXR0cmlidXRlTmFtZXMgPSBPYmplY3Qua2V5cyhtYXApO1xuICAgICAgICBhbGxQYXNzZWQgPSBhdHRyaWJ1dGVOYW1lcy5sZW5ndGggIT09IDA7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICBhbGxQYXNzZWQgPVxuICAgICAgICAgICAgYWxsUGFzc2VkICYmXG4gICAgICAgICAgICBfLmhhc0F0dHJpYnV0ZShhY3R1YWwsIG5hbWUpICYmXG4gICAgICAgICAgICBfLmdldEF0dHJpYnV0ZShhY3R1YWwsIG5hbWUpID09PSBtYXBbbmFtZV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBhc3M6IGFsbFBhc3NlZCxcbiAgICAgICAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBgXG4gICAgICAgICAgICAgIEV4cGVjdGVkICR7YWN0dWFsLm91dGVySFRNTH0gJHtcbiAgICAgICAgICAgICAgYWxsUGFzc2VkID8gJ25vdCAnIDogJydcbiAgICAgICAgICAgIH0gYXR0cmlidXRlcyB0byBjb250YWluXG4gICAgICAgICAgICAgICcke0pTT04uc3RyaW5naWZ5KG1hcCl9J1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVjayBlbGVtZW50J3MgaW5saW5lIHN0eWxlcyBvbmx5XG4gICAqL1xuICB0b0hhdmVTdHlsZTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBidWlsZENvbXBhcmVTdHlsZUZ1bmN0aW9uKHRydWUpLFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGVsZW1lbnQncyBjc3Mgc3R5bGVzaGVldCBvbmx5IChpZiBub3QgcHJlc2VudCBpbmxpbmUpXG4gICAqL1xuICB0b0hhdmVDU1M6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogYnVpbGRDb21wYXJlU3R5bGVGdW5jdGlvbihmYWxzZSksXG4gICAgfTtcbiAgfSxcbn07XG5cbi8qKlxuICogQ3VycmllZCB2YWx1ZSB0byBmdW5jdGlvbiB0byBjaGVjayBzdHlsZXMgdGhhdCBhcmUgaW5saW5lIG9yIGluIGEgc3R5bGVzaGVldCBmb3IgdGhlXG4gKiBzcGVjaWZpZWQgRE9NIGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkQ29tcGFyZVN0eWxlRnVuY3Rpb24oaW5saW5lT25seSA9IHRydWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChcbiAgICBhY3R1YWw6IGFueSxcbiAgICBzdHlsZXM6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9IHwgc3RyaW5nLFxuICAgIHN0eWxlcjogU3R5bGVVdGlsc1xuICApIHtcbiAgICBjb25zdCBmb3VuZCA9IHt9O1xuICAgIGNvbnN0IHN0eWxlTWFwOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSA9IHt9O1xuXG4gICAgaWYgKHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzdHlsZU1hcFtzdHlsZXNdID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIE9iamVjdC5hc3NpZ24oc3R5bGVNYXAsIHN0eWxlcyk7XG4gICAgfVxuXG4gICAgbGV0IGFsbFBhc3NlZCA9IE9iamVjdC5rZXlzKHN0eWxlTWFwKS5sZW5ndGggIT09IDA7XG4gICAgT2JqZWN0LmtleXMoc3R5bGVNYXApLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIGxldCB7IGVsSGFzU3R5bGUsIGN1cnJlbnQgfSA9IGhhc1ByZWZpeGVkU3R5bGVzKFxuICAgICAgICBhY3R1YWwsXG4gICAgICAgIHByb3AsXG4gICAgICAgIHN0eWxlTWFwW3Byb3BdLFxuICAgICAgICBpbmxpbmVPbmx5LFxuICAgICAgICBzdHlsZXJcbiAgICAgICk7XG4gICAgICBhbGxQYXNzZWQgPSBhbGxQYXNzZWQgJiYgZWxIYXNTdHlsZTtcbiAgICAgIGlmICghZWxIYXNTdHlsZSkge1xuICAgICAgICBleHRlbmRPYmplY3QoZm91bmQsIGN1cnJlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhc3M6IGFsbFBhc3NlZCxcbiAgICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlU3RyID1cbiAgICAgICAgICB0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgPyBzdHlsZU1hcFxuICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShzdHlsZU1hcCwgbnVsbCwgMik7XG4gICAgICAgIGNvbnN0IGZvdW5kVmFsdWVTdHIgPSBpbmxpbmVPbmx5XG4gICAgICAgICAgPyBhY3R1YWwub3V0ZXJIVE1MXG4gICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShmb3VuZCk7XG4gICAgICAgIHJldHVybiBgXG4gICAgICAgICAgRXhwZWN0ZWQgJHtmb3VuZFZhbHVlU3RyfSR7IWFsbFBhc3NlZCA/ICcnIDogJyBub3QnfSB0byBjb250YWluIHRoZVxuICAgICAgICAgIENTUyAke1xuICAgICAgICAgICAgdHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycgPyAncHJvcGVydHknIDogJ3N0eWxlcydcbiAgICAgICAgICB9ICcke2V4cGVjdGVkVmFsdWVTdHJ9J1xuICAgICAgICBgO1xuICAgICAgfSxcbiAgICB9O1xuICB9O1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHByZXNlbmNlIG9mIHJlcXVlc3RlZCBzdHlsZSBvciB1c2UgZmFsbGJhY2tcbiAqIHRvIHBvc3NpYmxlIGBwcmVmaXhlZGAgc3R5bGVzLiBVc2VmdWwgd2hlbiBzb21lIGJyb3dzZXJzXG4gKiAoU2FmYXJpLCBJRSwgZXRjKSB3aWxsIHVzZSBwcmVmaXhlZCBzdHlsZSBpbnN0ZWFkIG9mIGRlZmF1bHRzLlxuICovXG5mdW5jdGlvbiBoYXNQcmVmaXhlZFN0eWxlcyhcbiAgYWN0dWFsOiBIVE1MRWxlbWVudCxcbiAga2V5OiBzdHJpbmcsXG4gIHZhbHVlOiBzdHJpbmcsXG4gIGlubGluZU9ubHk6IGJvb2xlYW4sXG4gIHN0eWxlcjogU3R5bGVVdGlsc1xuKSB7XG4gIGNvbnN0IGN1cnJlbnQgPSB7fTtcblxuICBpZiAodmFsdWUgPT09ICcqJykge1xuICAgIHJldHVybiB7XG4gICAgICBlbEhhc1N0eWxlOiBzdHlsZXIubG9va3VwU3R5bGUoYWN0dWFsLCBrZXksIGlubGluZU9ubHkpICE9PSAnJyxcbiAgICAgIGN1cnJlbnQsXG4gICAgfTtcbiAgfVxuXG4gIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICBsZXQgZWxIYXNTdHlsZSA9IHN0eWxlci5sb29rdXBTdHlsZShhY3R1YWwsIGtleSwgaW5saW5lT25seSkgPT09IHZhbHVlO1xuICBpZiAoIWVsSGFzU3R5bGUpIHtcbiAgICBsZXQgcHJlZml4ZWRTdHlsZXMgPSBhcHBseUNzc1ByZWZpeGVzKHsgW2tleV06IHZhbHVlIH0pO1xuICAgIE9iamVjdC5rZXlzKHByZWZpeGVkU3R5bGVzKS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAvLyBTZWFyY2ggZm9yIG9wdGlvbmFsIHByZWZpeGVkIHZhbHVlc1xuICAgICAgZWxIYXNTdHlsZSA9XG4gICAgICAgIGVsSGFzU3R5bGUgfHxcbiAgICAgICAgc3R5bGVyLmxvb2t1cFN0eWxlKGFjdHVhbCwgcHJvcCwgaW5saW5lT25seSkgPT09IHByZWZpeGVkU3R5bGVzW3Byb3BdO1xuICAgIH0pO1xuICB9XG4gIC8vIFJldHVybiBCT1RIIGNvbmZpcm1hdGlvbiBhbmQgY3VycmVudCBjb21wdXRlZCBrZXkgdmFsdWVzIChpZiBjb25maXJtYXRpb24gPT0gZmFsc2UpXG4gIHJldHVybiB7IGVsSGFzU3R5bGUsIGN1cnJlbnQgfTtcbn1cblxuZnVuY3Rpb24gZWxlbWVudFRleHQobjogYW55KTogc3RyaW5nIHtcbiAgY29uc3QgaGFzTm9kZXMgPSAobTogYW55KSA9PiB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBfLmNoaWxkTm9kZXMobSk7XG4gICAgcmV0dXJuIGNoaWxkcmVuICYmIGNoaWxkcmVuWydsZW5ndGgnXTtcbiAgfTtcblxuICBpZiAobiBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIG4ubWFwKGVsZW1lbnRUZXh0KS5qb2luKCcnKTtcbiAgfVxuXG4gIGlmIChfLmlzQ29tbWVudE5vZGUobikpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoXy5pc0VsZW1lbnROb2RlKG4pICYmIF8udGFnTmFtZShuKSA9PSAnQ09OVEVOVCcpIHtcbiAgICByZXR1cm4gZWxlbWVudFRleHQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KF8uZ2V0RGlzdHJpYnV0ZWROb2RlcyhuKSkpO1xuICB9XG5cbiAgaWYgKF8uaGFzU2hhZG93Um9vdChuKSkge1xuICAgIHJldHVybiBlbGVtZW50VGV4dChfLmNoaWxkTm9kZXNBc0xpc3QoXy5nZXRTaGFkb3dSb290KG4pKSk7XG4gIH1cblxuICBpZiAoaGFzTm9kZXMobikpIHtcbiAgICByZXR1cm4gZWxlbWVudFRleHQoXy5jaGlsZE5vZGVzQXNMaXN0KG4pKTtcbiAgfVxuXG4gIHJldHVybiBfLmdldFRleHQobik7XG59XG4iXX0=