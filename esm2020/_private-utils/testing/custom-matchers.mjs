const _global = (typeof window === 'undefined' ? global : window);
import { _dom as _ } from './dom-tools';
import { applyCssPrefixes, extendObject, } from '@ngbrackets/ngx-layout/_private-utils';
export const expect = _global.expect;
/**
 * NOTE: These custom JASMINE Matchers are used only
 *       in the Karma/Jasmine testing for the Layout Directives
 *       in `src/lib/flex/api`
 */
export const customMatchers = {
    toEqual: function (util) {
        return {
            compare: function (actual, expected) {
                return { pass: util.equals(actual, expected) };
            },
        };
    },
    toHaveText: function () {
        return {
            compare: function (actual, expectedText) {
                const actualText = elementText(actual);
                return {
                    pass: actualText == expectedText,
                    get message() {
                        return 'Expected ' + actualText + ' to be equal to ' + expectedText;
                    },
                };
            },
        };
    },
    toHaveCssClass: function () {
        return { compare: buildError(false), negativeCompare: buildError(true) };
        function buildError(isNot) {
            return function (actual, className) {
                return {
                    pass: _.hasClass(actual, className) == !isNot,
                    get message() {
                        return `
              Expected ${actual.outerHTML} ${isNot ? 'not ' : ''}
              to contain the CSS class '${className}'
            `;
                    },
                };
            };
        }
    },
    toHaveMap: function () {
        return {
            compare: function (actual, map) {
                let allPassed;
                allPassed = Object.keys(map).length !== 0;
                Object.keys(map).forEach((key) => {
                    allPassed = allPassed && actual[key] === map[key];
                });
                return {
                    pass: allPassed,
                    get message() {
                        return `
              Expected ${JSON.stringify(actual)} ${!allPassed ? ' ' : 'not '} to contain the
              '${JSON.stringify(map)}'
            `;
                    },
                };
            },
        };
    },
    toHaveAttributes: function () {
        return {
            compare: function (actual, map) {
                let allPassed;
                let attributeNames = Object.keys(map);
                allPassed = attributeNames.length !== 0;
                attributeNames.forEach((name) => {
                    allPassed =
                        allPassed &&
                            _.hasAttribute(actual, name) &&
                            _.getAttribute(actual, name) === map[name];
                });
                return {
                    pass: allPassed,
                    get message() {
                        return `
              Expected ${actual.outerHTML} ${allPassed ? 'not ' : ''} attributes to contain
              '${JSON.stringify(map)}'
            `;
                    },
                };
            },
        };
    },
    /**
     * Check element's inline styles only
     */
    toHaveStyle: function () {
        return {
            compare: buildCompareStyleFunction(true),
        };
    },
    /**
     * Check element's css stylesheet only (if not present inline)
     */
    toHaveCSS: function () {
        return {
            compare: buildCompareStyleFunction(false),
        };
    },
};
/**
 * Curried value to function to check styles that are inline or in a stylesheet for the
 * specified DOM element.
 */
function buildCompareStyleFunction(inlineOnly = true) {
    return function (actual, styles, styler) {
        const found = {};
        const styleMap = {};
        if (typeof styles === 'string') {
            styleMap[styles] = '';
        }
        else {
            Object.assign(styleMap, styles);
        }
        let allPassed = Object.keys(styleMap).length !== 0;
        Object.keys(styleMap).forEach((prop) => {
            let { elHasStyle, current } = hasPrefixedStyles(actual, prop, styleMap[prop], inlineOnly, styler);
            allPassed = allPassed && elHasStyle;
            if (!elHasStyle) {
                extendObject(found, current);
            }
        });
        return {
            pass: allPassed,
            get message() {
                const expectedValueStr = typeof styles === 'string'
                    ? styleMap
                    : JSON.stringify(styleMap, null, 2);
                const foundValueStr = inlineOnly
                    ? actual.outerHTML
                    : JSON.stringify(found);
                return `
          Expected ${foundValueStr}${!allPassed ? '' : ' not'} to contain the
          CSS ${typeof styles === 'string' ? 'property' : 'styles'} '${expectedValueStr}'
        `;
            },
        };
    };
}
/**
 * Validate presence of requested style or use fallback
 * to possible `prefixed` styles. Useful when some browsers
 * (Safari, IE, etc) will use prefixed style instead of defaults.
 */
function hasPrefixedStyles(actual, key, value, inlineOnly, styler) {
    const current = {};
    if (value === '*') {
        return {
            elHasStyle: styler.lookupStyle(actual, key, inlineOnly) !== '',
            current,
        };
    }
    value = value.trim();
    let elHasStyle = styler.lookupStyle(actual, key, inlineOnly) === value;
    if (!elHasStyle) {
        let prefixedStyles = applyCssPrefixes({ [key]: value });
        Object.keys(prefixedStyles).forEach((prop) => {
            // Search for optional prefixed values
            elHasStyle =
                elHasStyle ||
                    styler.lookupStyle(actual, prop, inlineOnly) === prefixedStyles[prop];
        });
    }
    // Return BOTH confirmation and current computed key values (if confirmation == false)
    return { elHasStyle, current };
}
function elementText(n) {
    const hasNodes = (m) => {
        const children = _.childNodes(m);
        return children && children['length'];
    };
    if (n instanceof Array) {
        return n.map(elementText).join('');
    }
    if (_.isCommentNode(n)) {
        return '';
    }
    if (_.isElementNode(n) && _.tagName(n) == 'CONTENT') {
        return elementText(Array.prototype.slice.apply(_.getDistributedNodes(n)));
    }
    if (_.hasShadowRoot(n)) {
        return elementText(_.childNodesAsList(_.getShadowRoot(n)));
    }
    if (hasNodes(n)) {
        return elementText(_.childNodesAsList(n));
    }
    return _.getText(n);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VzdG9tLW1hdGNoZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbGlicy9mbGV4LWxheW91dC9fcHJpdmF0ZS11dGlscy90ZXN0aW5nL2N1c3RvbS1tYXRjaGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFRQSxNQUFNLE9BQU8sR0FBUSxDQUFDLE9BQU8sTUFBTSxLQUFLLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUV2RSxPQUFPLEVBQUUsSUFBSSxJQUFJLENBQUMsRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUd4QyxPQUFPLEVBQ0wsZ0JBQWdCLEVBQ2hCLFlBQVksR0FDYixNQUFNLHVDQUF1QyxDQUFDO0FBRS9DLE1BQU0sQ0FBQyxNQUFNLE1BQU0sR0FBcUMsT0FBTyxDQUFDLE1BQU0sQ0FBQztBQTBEdkU7Ozs7R0FJRztBQUNILE1BQU0sQ0FBQyxNQUFNLGNBQWMsR0FBbUM7SUFDNUQsT0FBTyxFQUFFLFVBQVUsSUFBSTtRQUNyQixPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQVUsTUFBVyxFQUFFLFFBQWE7Z0JBQzNDLE9BQU8sRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsUUFBUSxDQUFDLEVBQUUsQ0FBQztZQUNqRCxDQUFDO1NBQ0YsQ0FBQztJQUNKLENBQUM7SUFFRCxVQUFVLEVBQUU7UUFDVixPQUFPO1lBQ0wsT0FBTyxFQUFFLFVBQVUsTUFBVyxFQUFFLFlBQW9CO2dCQUNsRCxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3ZDLE9BQU87b0JBQ0wsSUFBSSxFQUFFLFVBQVUsSUFBSSxZQUFZO29CQUNoQyxJQUFJLE9BQU87d0JBQ1QsT0FBTyxXQUFXLEdBQUcsVUFBVSxHQUFHLGtCQUFrQixHQUFHLFlBQVksQ0FBQztvQkFDdEUsQ0FBQztpQkFDRixD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QUFDLENBQUMsQ0FBQyxhQUFhLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQzVEO0lBRUQsSUFBSSxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDZixPQUFPLFdBQVcsQ0FBQyxDQUFDLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUMzQztJQUVELE9BQU8sQ0FBQyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5kZWNsYXJlIHZhciBnbG9iYWw6IGFueTtcbmNvbnN0IF9nbG9iYWwgPSA8YW55Pih0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHdpbmRvdyk7XG5cbmltcG9ydCB7IF9kb20gYXMgXyB9IGZyb20gJy4vZG9tLXRvb2xzJztcblxuaW1wb3J0IHsgU3R5bGVVdGlscyB9IGZyb20gJ0BuZ2JyYWNrZXRzL25neC1sYXlvdXQvY29yZSc7XG5pbXBvcnQge1xuICBhcHBseUNzc1ByZWZpeGVzLFxuICBleHRlbmRPYmplY3QsXG59IGZyb20gJ0BuZ2JyYWNrZXRzL25neC1sYXlvdXQvX3ByaXZhdGUtdXRpbHMnO1xuXG5leHBvcnQgY29uc3QgZXhwZWN0OiAoYWN0dWFsOiBhbnkpID0+IE5nTWF0Y2hlcnMgPSA8YW55Pl9nbG9iYWwuZXhwZWN0O1xuXG4vKipcbiAqIEphc21pbmUgbWF0Y2hlcnMgdGhhdCBjaGVjayBBbmd1bGFyIHNwZWNpZmljIGNvbmRpdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTmdNYXRjaGVycyBleHRlbmRzIGphc21pbmUuTWF0Y2hlcnM8YW55PiB7XG4gIC8qKlxuICAgKiBFeHBlY3QgdGhlIGVsZW1lbnQgdG8gaGF2ZSBleGFjdGx5IHRoZSBnaXZlbiB0ZXh0LlxuICAgKlxuICAgKiAjIyBFeGFtcGxlXG4gICAqXG4gICAqIHtAZXhhbXBsZSB0ZXN0aW5nL3RzL21hdGNoZXJzLnRzIHJlZ2lvbj0ndG9IYXZlVGV4dCd9XG4gICAqL1xuICB0b0hhdmVUZXh0KGV4cGVjdGVkOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDb21wYXJlIGtleTp2YWx1ZSBwYWlycyBhcyBtYXRjaGluZyBFWEFDVExZXG4gICAqL1xuICB0b0hhdmVNYXAoZXhwZWN0ZWQ6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9KTogYm9vbGVhbjtcblxuICAvKipcbiAgICogRXhwZWN0IHRoZSBlbGVtZW50IHRvIGhhdmUgdGhlIGdpdmVuIENTUyBjbGFzcy5cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgdGVzdGluZy90cy9tYXRjaGVycy50cyByZWdpb249J3RvSGF2ZUNzc0NsYXNzJ31cbiAgICovXG4gIHRvSGF2ZUNzc0NsYXNzKGV4cGVjdGVkOiBzdHJpbmcpOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhlIGVsZW1lbnQgdG8gaGF2ZSB0aGUgZ2l2ZW4gcGFpcnMgb2YgYXR0cmlidXRlIG5hbWUgYW5kIGF0dHJpYnV0ZSB2YWx1ZVxuICAgKi9cbiAgdG9IYXZlQXR0cmlidXRlcyhleHBlY3RlZDogeyBbazogc3RyaW5nXTogc3RyaW5nIH0pOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBFeHBlY3QgdGhlIGVsZW1lbnQgdG8gaGF2ZSB0aGUgZ2l2ZW4gQ1NTIHN0eWxlcyBpbmplY3RlZCBJTkxJTkVcbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgdGVzdGluZy90cy9tYXRjaGVycy50cyByZWdpb249J3RvSGF2ZVN0eWxlJ31cbiAgICovXG4gIHRvSGF2ZVN0eWxlKGV4cGVjdGVkOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSB8IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEV4cGVjdCB0aGUgZWxlbWVudCB0byBoYXZlIHRoZSBnaXZlbiBDU1MgaW5saW5lIE9SIGNvbXB1dGVkIHN0eWxlcy5cbiAgICpcbiAgICogIyMgRXhhbXBsZVxuICAgKlxuICAgKiB7QGV4YW1wbGUgdGVzdGluZy90cy9tYXRjaGVycy50cyByZWdpb249J3RvSGF2ZVN0eWxlJ31cbiAgICovXG4gIHRvSGF2ZVN0eWxlKGV4cGVjdGVkOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSB8IHN0cmluZyk6IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEludmVydCB0aGUgbWF0Y2hlcnMuXG4gICAqL1xuICBub3Q6IE5nTWF0Y2hlcnM7XG59XG5cbi8qKlxuICogTk9URTogVGhlc2UgY3VzdG9tIEpBU01JTkUgTWF0Y2hlcnMgYXJlIHVzZWQgb25seVxuICogICAgICAgaW4gdGhlIEthcm1hL0phc21pbmUgdGVzdGluZyBmb3IgdGhlIExheW91dCBEaXJlY3RpdmVzXG4gKiAgICAgICBpbiBgc3JjL2xpYi9mbGV4L2FwaWBcbiAqL1xuZXhwb3J0IGNvbnN0IGN1c3RvbU1hdGNoZXJzOiBqYXNtaW5lLkN1c3RvbU1hdGNoZXJGYWN0b3JpZXMgPSB7XG4gIHRvRXF1YWw6IGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChhY3R1YWw6IGFueSwgZXhwZWN0ZWQ6IGFueSkge1xuICAgICAgICByZXR1cm4geyBwYXNzOiB1dGlsLmVxdWFscyhhY3R1YWwsIGV4cGVjdGVkKSB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuXG4gIHRvSGF2ZVRleHQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24gKGFjdHVhbDogYW55LCBleHBlY3RlZFRleHQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBhY3R1YWxUZXh0ID0gZWxlbWVudFRleHQoYWN0dWFsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwYXNzOiBhY3R1YWxUZXh0ID09IGV4cGVjdGVkVGV4dCxcbiAgICAgICAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgICAgIHJldHVybiAnRXhwZWN0ZWQgJyArIGFjdHVhbFRleHQgKyAnIHRvIGJlIGVxdWFsIHRvICcgKyBleHBlY3RlZFRleHQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcblxuICB0b0hhdmVDc3NDbGFzczogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7IGNvbXBhcmU6IGJ1aWxkRXJyb3IoZmFsc2UpLCBuZWdhdGl2ZUNvbXBhcmU6IGJ1aWxkRXJyb3IodHJ1ZSkgfTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkRXJyb3IoaXNOb3Q6IGJvb2xlYW4pIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYWN0dWFsOiBhbnksIGNsYXNzTmFtZTogc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogXy5oYXNDbGFzcyhhY3R1YWwsIGNsYXNzTmFtZSkgPT0gIWlzTm90LFxuICAgICAgICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgRXhwZWN0ZWQgJHthY3R1YWwub3V0ZXJIVE1MfSAke2lzTm90ID8gJ25vdCAnIDogJyd9XG4gICAgICAgICAgICAgIHRvIGNvbnRhaW4gdGhlIENTUyBjbGFzcyAnJHtjbGFzc05hbWV9J1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgdG9IYXZlTWFwOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGZ1bmN0aW9uIChcbiAgICAgICAgYWN0dWFsOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfSxcbiAgICAgICAgbWFwOiB7IFtrOiBzdHJpbmddOiBzdHJpbmcgfVxuICAgICAgKSB7XG4gICAgICAgIGxldCBhbGxQYXNzZWQ6IGJvb2xlYW47XG4gICAgICAgIGFsbFBhc3NlZCA9IE9iamVjdC5rZXlzKG1hcCkubGVuZ3RoICE9PSAwO1xuICAgICAgICBPYmplY3Qua2V5cyhtYXApLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgIGFsbFBhc3NlZCA9IGFsbFBhc3NlZCAmJiBhY3R1YWxba2V5XSA9PT0gbWFwW2tleV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWxsUGFzc2VkLFxuICAgICAgICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgRXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShhY3R1YWwpfSAke1xuICAgICAgICAgICAgICAhYWxsUGFzc2VkID8gJyAnIDogJ25vdCAnXG4gICAgICAgICAgICB9IHRvIGNvbnRhaW4gdGhlXG4gICAgICAgICAgICAgICcke0pTT04uc3RyaW5naWZ5KG1hcCl9J1xuICAgICAgICAgICAgYDtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxuXG4gIHRvSGF2ZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tcGFyZTogZnVuY3Rpb24gKGFjdHVhbDogYW55LCBtYXA6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgICAgIGxldCBhbGxQYXNzZWQ6IGJvb2xlYW47XG4gICAgICAgIGxldCBhdHRyaWJ1dGVOYW1lcyA9IE9iamVjdC5rZXlzKG1hcCk7XG4gICAgICAgIGFsbFBhc3NlZCA9IGF0dHJpYnV0ZU5hbWVzLmxlbmd0aCAhPT0gMDtcbiAgICAgICAgYXR0cmlidXRlTmFtZXMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgIGFsbFBhc3NlZCA9XG4gICAgICAgICAgICBhbGxQYXNzZWQgJiZcbiAgICAgICAgICAgIF8uaGFzQXR0cmlidXRlKGFjdHVhbCwgbmFtZSkgJiZcbiAgICAgICAgICAgIF8uZ2V0QXR0cmlidXRlKGFjdHVhbCwgbmFtZSkgPT09IG1hcFtuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcGFzczogYWxsUGFzc2VkLFxuICAgICAgICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICAgICAgRXhwZWN0ZWQgJHthY3R1YWwub3V0ZXJIVE1MfSAke1xuICAgICAgICAgICAgICBhbGxQYXNzZWQgPyAnbm90ICcgOiAnJ1xuICAgICAgICAgICAgfSBhdHRyaWJ1dGVzIHRvIGNvbnRhaW5cbiAgICAgICAgICAgICAgJyR7SlNPTi5zdHJpbmdpZnkobWFwKX0nXG4gICAgICAgICAgICBgO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrIGVsZW1lbnQncyBpbmxpbmUgc3R5bGVzIG9ubHlcbiAgICovXG4gIHRvSGF2ZVN0eWxlOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbXBhcmU6IGJ1aWxkQ29tcGFyZVN0eWxlRnVuY3Rpb24odHJ1ZSksXG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2sgZWxlbWVudCdzIGNzcyBzdHlsZXNoZWV0IG9ubHkgKGlmIG5vdCBwcmVzZW50IGlubGluZSlcbiAgICovXG4gIHRvSGF2ZUNTUzogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21wYXJlOiBidWlsZENvbXBhcmVTdHlsZUZ1bmN0aW9uKGZhbHNlKSxcbiAgICB9O1xuICB9LFxufTtcblxuLyoqXG4gKiBDdXJyaWVkIHZhbHVlIHRvIGZ1bmN0aW9uIHRvIGNoZWNrIHN0eWxlcyB0aGF0IGFyZSBpbmxpbmUgb3IgaW4gYSBzdHlsZXNoZWV0IGZvciB0aGVcbiAqIHNwZWNpZmllZCBET00gZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRDb21wYXJlU3R5bGVGdW5jdGlvbihpbmxpbmVPbmx5ID0gdHJ1ZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKFxuICAgIGFjdHVhbDogYW55LFxuICAgIHN0eWxlczogeyBbazogc3RyaW5nXTogc3RyaW5nIH0gfCBzdHJpbmcsXG4gICAgc3R5bGVyOiBTdHlsZVV0aWxzXG4gICkge1xuICAgIGNvbnN0IGZvdW5kID0ge307XG4gICAgY29uc3Qgc3R5bGVNYXA6IHsgW2s6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG5cbiAgICBpZiAodHlwZW9mIHN0eWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0eWxlTWFwW3N0eWxlc10gPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZU1hcCwgc3R5bGVzKTtcbiAgICB9XG5cbiAgICBsZXQgYWxsUGFzc2VkID0gT2JqZWN0LmtleXMoc3R5bGVNYXApLmxlbmd0aCAhPT0gMDtcbiAgICBPYmplY3Qua2V5cyhzdHlsZU1hcCkuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgbGV0IHsgZWxIYXNTdHlsZSwgY3VycmVudCB9ID0gaGFzUHJlZml4ZWRTdHlsZXMoXG4gICAgICAgIGFjdHVhbCxcbiAgICAgICAgcHJvcCxcbiAgICAgICAgc3R5bGVNYXBbcHJvcF0sXG4gICAgICAgIGlubGluZU9ubHksXG4gICAgICAgIHN0eWxlclxuICAgICAgKTtcbiAgICAgIGFsbFBhc3NlZCA9IGFsbFBhc3NlZCAmJiBlbEhhc1N0eWxlO1xuICAgICAgaWYgKCFlbEhhc1N0eWxlKSB7XG4gICAgICAgIGV4dGVuZE9iamVjdChmb3VuZCwgY3VycmVudCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcGFzczogYWxsUGFzc2VkLFxuICAgICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVTdHIgPVxuICAgICAgICAgIHR5cGVvZiBzdHlsZXMgPT09ICdzdHJpbmcnXG4gICAgICAgICAgICA/IHN0eWxlTWFwXG4gICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHN0eWxlTWFwLCBudWxsLCAyKTtcbiAgICAgICAgY29uc3QgZm91bmRWYWx1ZVN0ciA9IGlubGluZU9ubHlcbiAgICAgICAgICA/IGFjdHVhbC5vdXRlckhUTUxcbiAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KGZvdW5kKTtcbiAgICAgICAgcmV0dXJuIGBcbiAgICAgICAgICBFeHBlY3RlZCAke2ZvdW5kVmFsdWVTdHJ9JHshYWxsUGFzc2VkID8gJycgOiAnIG5vdCd9IHRvIGNvbnRhaW4gdGhlXG4gICAgICAgICAgQ1NTICR7XG4gICAgICAgICAgICB0eXBlb2Ygc3R5bGVzID09PSAnc3RyaW5nJyA/ICdwcm9wZXJ0eScgOiAnc3R5bGVzJ1xuICAgICAgICAgIH0gJyR7ZXhwZWN0ZWRWYWx1ZVN0cn0nXG4gICAgICAgIGA7XG4gICAgICB9LFxuICAgIH07XG4gIH07XG59XG5cbi8qKlxuICogVmFsaWRhdGUgcHJlc2VuY2Ugb2YgcmVxdWVzdGVkIHN0eWxlIG9yIHVzZSBmYWxsYmFja1xuICogdG8gcG9zc2libGUgYHByZWZpeGVkYCBzdHlsZXMuIFVzZWZ1bCB3aGVuIHNvbWUgYnJvd3NlcnNcbiAqIChTYWZhcmksIElFLCBldGMpIHdpbGwgdXNlIHByZWZpeGVkIHN0eWxlIGluc3RlYWQgb2YgZGVmYXVsdHMuXG4gKi9cbmZ1bmN0aW9uIGhhc1ByZWZpeGVkU3R5bGVzKFxuICBhY3R1YWw6IEhUTUxFbGVtZW50LFxuICBrZXk6IHN0cmluZyxcbiAgdmFsdWU6IHN0cmluZyxcbiAgaW5saW5lT25seTogYm9vbGVhbixcbiAgc3R5bGVyOiBTdHlsZVV0aWxzXG4pIHtcbiAgY29uc3QgY3VycmVudCA9IHt9O1xuXG4gIGlmICh2YWx1ZSA9PT0gJyonKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVsSGFzU3R5bGU6IHN0eWxlci5sb29rdXBTdHlsZShhY3R1YWwsIGtleSwgaW5saW5lT25seSkgIT09ICcnLFxuICAgICAgY3VycmVudCxcbiAgICB9O1xuICB9XG5cbiAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIGxldCBlbEhhc1N0eWxlID0gc3R5bGVyLmxvb2t1cFN0eWxlKGFjdHVhbCwga2V5LCBpbmxpbmVPbmx5KSA9PT0gdmFsdWU7XG4gIGlmICghZWxIYXNTdHlsZSkge1xuICAgIGxldCBwcmVmaXhlZFN0eWxlcyA9IGFwcGx5Q3NzUHJlZml4ZXMoeyBba2V5XTogdmFsdWUgfSk7XG4gICAgT2JqZWN0LmtleXMocHJlZml4ZWRTdHlsZXMpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgIC8vIFNlYXJjaCBmb3Igb3B0aW9uYWwgcHJlZml4ZWQgdmFsdWVzXG4gICAgICBlbEhhc1N0eWxlID1cbiAgICAgICAgZWxIYXNTdHlsZSB8fFxuICAgICAgICBzdHlsZXIubG9va3VwU3R5bGUoYWN0dWFsLCBwcm9wLCBpbmxpbmVPbmx5KSA9PT0gcHJlZml4ZWRTdHlsZXNbcHJvcF07XG4gICAgfSk7XG4gIH1cbiAgLy8gUmV0dXJuIEJPVEggY29uZmlybWF0aW9uIGFuZCBjdXJyZW50IGNvbXB1dGVkIGtleSB2YWx1ZXMgKGlmIGNvbmZpcm1hdGlvbiA9PSBmYWxzZSlcbiAgcmV0dXJuIHsgZWxIYXNTdHlsZSwgY3VycmVudCB9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50VGV4dChuOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBoYXNOb2RlcyA9IChtOiBhbnkpID0+IHtcbiAgICBjb25zdCBjaGlsZHJlbiA9IF8uY2hpbGROb2RlcyhtKTtcbiAgICByZXR1cm4gY2hpbGRyZW4gJiYgY2hpbGRyZW5bJ2xlbmd0aCddO1xuICB9O1xuXG4gIGlmIChuIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICByZXR1cm4gbi5tYXAoZWxlbWVudFRleHQpLmpvaW4oJycpO1xuICB9XG5cbiAgaWYgKF8uaXNDb21tZW50Tm9kZShuKSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmIChfLmlzRWxlbWVudE5vZGUobikgJiYgXy50YWdOYW1lKG4pID09ICdDT05URU5UJykge1xuICAgIHJldHVybiBlbGVtZW50VGV4dChBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoXy5nZXREaXN0cmlidXRlZE5vZGVzKG4pKSk7XG4gIH1cblxuICBpZiAoXy5oYXNTaGFkb3dSb290KG4pKSB7XG4gICAgcmV0dXJuIGVsZW1lbnRUZXh0KF8uY2hpbGROb2Rlc0FzTGlzdChfLmdldFNoYWRvd1Jvb3QobikpKTtcbiAgfVxuXG4gIGlmIChoYXNOb2RlcyhuKSkge1xuICAgIHJldHVybiBlbGVtZW50VGV4dChfLmNoaWxkTm9kZXNBc0xpc3QobikpO1xuICB9XG5cbiAgcmV0dXJuIF8uZ2V0VGV4dChuKTtcbn1cbiJdfQ==